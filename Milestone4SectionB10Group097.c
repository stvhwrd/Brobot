#pragma config(Sensor, in1,    IRsensor, sensorReflection)
#pragma config(Sensor, dgtl1,  sonar,          sensorSONAR_mm)
#pragma config(Sensor, dgtl2,  button1,        sensorTouch)
#pragma config(Sensor, dgtl6,  frontRightLimitSwitch, sensorTouch)
#pragma config(Sensor, dgtl7,  frontLeftLimitSwitch, sensorTouch)
#pragma config(Motor,  port1,           rightMotor,    tmotorVex393_HBridge, openLoop)
#pragma config(Motor,  port5,           pincerMotor,  tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,           armMotor,      tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port10,          leftMotor,     tmotorVex393_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/**
 * 	ENGR120 B10 Group 097:  	Stevie Howard
 *								Clayton Ikuta
 *								Evan Kenzle
*/


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++//
//+++++++++++++++++++++++++++ CONSTANTS (tweak values here instead of throughout code) +++++++++++++++++++++++++++//

//////// SPEEDS ////////
#define	PRIMARY_SCAN_TURN_SPEED			30		// how quickly to turn during primary scan (motor value 0 - 127)
#define	SECONDARY_SCAN_TURN_SPEED		25		// how quickly to turn during secondary scan (motor value 0 - 127)
#define	TURNAROUND_SPEED				30		// how quickly to turn 90 degrees (motor value 0 - 127)
#define	REVERSE_SPEED					25		// absolute speed of reverse drive - should not be negative (motor value 0 - 127)
#define	FORWARD_SPEED					40		// how fast to drive forward in open space (motor value 0 - 127)
#define SLOW_SPEED						20 		// how fast to creep forward when in close range (motor value 0 - 127)

//////// TIMING /////////
#define	PRIMARY_SCAN_TIME				4000 	// how long to conduct the first high speed scan (milliseconds)
#define	SECONDARY_SCAN_TIME				6000 	// how long to conduct the second lower speed scan (milliseconds)
#define	TURNAROUND_TIME					1000 	// calibrated for a 90 degree turn (milliseconds)
#define	REVERSE_TIME					1500 	// how long to drive in reverse for (milliseconds)
#define PATROL_DRIVE_TIME 				2500 	// calibrated for a ~1 metre drive (milliseconds)

//////// DISTANCES //////
#define	CLOSE_RANGE						600		// sonar distance from beacon/wall at which robot should take a slower approach (millimeters)
#define POINT_BLANK						140		// sonar distance from beacon/wall at which target can be acquired/released (millimeters)

//////// MISCELLANEOUS //////
#define	ROUGH_IR_TOLERANCE				50		// unitless "degrees of freedom" from IRMax when finding beacon long range
#define	PRECISE_IR_TOLERANCE			20		// unitless "degrees of freedom" from IRMax when finding beacon short range
#define	LEFT_WHEEL_MOTOR_CORRECTION		1.3 	// factor to multiply leftMotor output by to compensate for rightMotor's greater strength
#define	NUMBER_OF_CELEBRATIONS			3		// repititions of task completion action a.k.a. "celebration"


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++//
//+++++++++++++++++++++++++++ GLOBAL VARIABLES +++++++++++++++++++++++++++//

int ambientIR = 5000;	// level of IR naturally occurring in the room in real time must be acknowledged to avoid false positives.
int sonarMax = 0;	// used to find open spaces in case robot is out of IR sensor range.
int IRMax = 0;	// highest value of IR observed.  We assume this to be coming from the beacon.

typedef enum FSM{	// declare the finite state machine's states
	STANDBY,
	SCAN_PRIMARY,
	SCAN_SECONDARY,
	DRIVE_PATROL,
	DRIVE_TO_BEACON_FAST,
	DRIVE_TO_BEACON_SLOW,
	DRIVE_TO_WALL,
	TARGET_ACQUIRING,
	TARGET_DISPOSING,
	SIGNAL_COMPLETION,
} State;


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++//
//+++++++++++++++++++++++++++ HELPER FUNCTIONS +++++++++++++++++++++++++++//

/**
*	stops wheel motors
*/
void stopWheels()
{
	motor[leftMotor] = motor[rightMotor] = 0;
}



/**
*	robot drives in reverse
*/
void backUp()
{
	stopWheels();		// brief pause to prevent rocking
	wait1Msec(400);

	motor[leftMotor] = -(REVERSE_SPEED*LEFT_WHEEL_MOTOR_CORRECTION);		// turn both wheels in reverse
	motor[rightMotor] = -REVERSE_SPEED;

	wait1Msec(REVERSE_TIME);					// for a short time

	stopWheels();							// then stop
}



/**
*	robot turns around 180 degrees
*/
void turnAround()
{
	stopWheels();

	motor[leftMotor] = -(TURNAROUND_SPEED*LEFT_WHEEL_MOTOR_CORRECTION);	// turn wheels in opposite directions
	motor[rightMotor] = TURNAROUND_SPEED;

	wait1Msec(TURNAROUND_TIME);		// for a specific time

	stopWheels();		// then stop
}



/**
*	read only the median value of every 3 sonar readings to eliminate outliers
*/
int medianFilter()
{
	int first = 0, second = 0, third = 0;

	// take three sonar readings
	first = SensorValue(sonar);
	wait1Msec(70);		// update rate of the ultrasonic sensor is 70 milliseconds (apparently)

	second = SensorValue(sonar);
	wait1Msec(70);

	third = SensorValue(sonar);
	wait1Msec(70);

	// calculate and return the median of the three values
	if((first >= second && first <= third) || (first <= second && first >= third))
	{
		return first;
	}
	else if((second >= first && second <= third) || (second <= first && second >= third))
	{
		return second;
	}
	else
	{
		return third;
	}
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++//
//+++++++++++++++++++++++++++ MACHINE STATE FUNCTIONS +++++++++++++++++++++++++++//


/**
*	standingBy(): 	Default machine state.  Robot stands by while polling for a button push.
* 	input: 			none
* 	output: 		if button1 pushed:  go to SCAN_PRIMARY
*/
State standingBy()
{
	stopWheels();	// robot is stationary by default.

	if(SensorValue(button1))	// if button is pushed,
	{
		return SCAN_PRIMARY;	// begin seeking beacon.
	}
	return STANDBY;		// otherwise keep standing by.
}



/*
*	primaryScan():	Seek out beacon by rotating and sampling for IR, then turn to focus on point of maximum IR emission.
* 	input: 			none
* 	output: 		if a significant IR is found, go to DRIVE_TO_BEACON_FAST
*					otherwise begin a new search, go to DRIVE_PATROL
*/
State primaryScan()
{
	IRMax = 0; 	// highest value that the center IR sensor is exposed to
	sonarMax = 0; 	// highest value that the ultrasonic sensor is exposed to

	//// PHASE 1: ////
	// begin rotating to capture IR values 360 degrees in current position
	clearTimer(T1);
	while(time1[T1] < PRIMARY_SCAN_TIME)
	{
		if(SensorValue(IRsensor) > IRMax)
		{
			IRMax = SensorValue(IRsensor);		// record the highest IR observed from current position
		}
		if(SensorValue(IRsensor) < ambientIR)
		{
			ambientIR = SensorValue(IRsensor);	// record the lowest IR observed in the room (to ignore that amount)
		}
		motor[leftMotor] = -(PRIMARY_SCAN_TURN_SPEED*LEFT_WHEEL_MOTOR_CORRECTION);
		motor[rightMotor] = PRIMARY_SCAN_TURN_SPEED;
	}

	//// PHASE 2: ////
	// continue rotating but slow down to focus on beacon (source of IRMax)
	clearTimer(T1);
	while(time1[T1] < PRIMARY_SCAN_TIME)
	{
		if(SensorValue(IRsensor) > (ambientIR + ROUGH_IR_TOLERANCE))
		{									// IR beacon detected.
			stopWheels();					// cease rotations,
			return(DRIVE_TO_BEACON_FAST);	// change states, approach beacon.
		}
		motor[leftMotor] = -(SECONDARY_SCAN_TURN_SPEED*LEFT_WHEEL_MOTOR_CORRECTION);
		motor[rightMotor] = SECONDARY_SCAN_TURN_SPEED;
	}

	stopWheels();	//if we cannot detect an IR signal greater than ambient, we move into open space to try again
	return(DRIVE_PATROL);
}



/**
*	onPatrol(): 	move into open space to attempt to detect beacon
* 	input: 			none
* 	output: 		go to SCAN_PRIMARY
*/
State onPatrol()
{
	sonarMax = 0;	// reset max sonar value for new position

	clearTimer(T1);
	while(time1[T1] < SECONDARY_SCAN_TIME)
	{ // robot reverses rotation to find where the sonarMax was	//
		if(SensorValue(sonar) >= sonarMax)
		{
			sonarMax = SensorValue(sonar);	// record the highest sonar value observed
		}
		motor[leftMotor] = -(SECONDARY_SCAN_TURN_SPEED*LEFT_WHEEL_MOTOR_CORRECTION);
		motor[rightMotor] = SECONDARY_SCAN_TURN_SPEED;
	}
	clearTimer(T1);
	while((SensorValue(sonar) <= (sonarMax - 100)))
	{ // robot continues rotation to find where the sonarMax was	//
		motor[leftMotor] = -(SECONDARY_SCAN_TURN_SPEED*LEFT_WHEEL_MOTOR_CORRECTION);
		motor[rightMotor] = SECONDARY_SCAN_TURN_SPEED;
	}
	stopWheels();		// found the open space in front of robot, cease rotations

	// move into the open space
	motor[leftMotor] = (FORWARD_SPEED*LEFT_WHEEL_MOTOR_CORRECTION);
	motor[rightMotor] = FORWARD_SPEED;
	wait1Msec(PATROL_DRIVE_TIME);
	stopWheels();

	return SCAN_PRIMARY; // attempt a new scan in this new area
}



/**
*	secondaryScan(): 	conduct a quick 120 degree scan to re-orient robot to beacon
* 	input: 				none
* 	output: 			if a significant IR is found, go to DRIVE_TO_BEACON_SLOW
*						otherwise begin a new search, go to DRIVE_PATROL
*/
State secondaryScan()
{
	int IRMax = 0; 	// highest value that the IR sensor is exposed to

	//// PHASE 1a: ////
	// robot rotates in place while recording IR values taken in
	clearTimer(T1);
	while(time1[T1] < SECONDARY_SCAN_TIME/2)
	{
		if(SensorValue(IRsensor) > IRMax)
		{
			IRMax = SensorValue(IRsensor);	// IRMax should be set to the HIGHEST value that IRsensor encounters while scanning
		}
		motor[leftMotor] = (SECONDARY_SCAN_TURN_SPEED*LEFT_WHEEL_MOTOR_CORRECTION);	// begin rotation to capture IR
		motor[rightMotor] = -SECONDARY_SCAN_TURN_SPEED;
	}

	stopWheels();	// finished collecting samples in one direction, stop rotation
	wait1Msec(200);	// pause to prevent rocking

	//// PHASE 1b: ////
	// begin rotating the opposite direction to complete the sweep
	clearTimer(T1);
	while(time1[T1] < SECONDARY_SCAN_TIME)
	{
		if(SensorValue(IRsensor) >= IRMax)
		{
			IRMax = SensorValue(IRsensor);	// IRMax should be set to the HIGHEST value that IRsensor encounters while scanning
		}
		motor[leftMotor] = -(SECONDARY_SCAN_TURN_SPEED*LEFT_WHEEL_MOTOR_CORRECTION);
		motor[rightMotor] = SECONDARY_SCAN_TURN_SPEED;
	}

	stopWheels();	//completed scan in both directions
	wait1Msec(200);	//pause

	//// PHASE 2: ////
	// begin rotating the opposite direction to focus on beacon (source of IRMax)
		clearTimer(T1);
		while(time1[T1] < SECONDARY_SCAN_TIME)
		{	// begin rotating the opposite direction to focus on beacon (source of IRMax)
			if(SensorValue(IRsensor) > (IRMax - PRECISE_IR_TOLERANCE))
			{	// as soon as IRMax +/- degrees of freedom is encountered,
				stopWheels();		// cease rotations
				return(DRIVE_TO_BEACON_SLOW);//IR Beacon detected. We would now go to SLOWLY_APPROACH_BEACON or whatever it's now called
			}
			motor[leftMotor] = (SECONDARY_SCAN_TURN_SPEED*LEFT_WHEEL_MOTOR_CORRECTION);
			motor[rightMotor] = -SECONDARY_SCAN_TURN_SPEED;
		}
	stopWheels();	//if we cannot detect a significant IR signal, we move into space and search again
	return(DRIVE_PATROL);
}



/**
* 	longRangeApproach():	Drive forward straight towards beacon.
* 	input: 					none
* 	output:					once robot is in close range, go to DRIVE_TO_BEACON_SLOW
*							otherwise go to SCAN_SECONDARY
*/
State longRangeApproach()
{
	// check first if we're within close range
	if(medianFilter() <= CLOSE_RANGE)
	{	// we're already oriented towards beacon, so we can drive slowly in current heading.
		return DRIVE_TO_BEACON_SLOW;
	}
	// drive towards beacon until we're in close range or lose IR focus
	while((medianFilter() > CLOSE_RANGE) && (SensorValue(IRsensor) > ambientIR + ROUGH_IR_TOLERANCE))
	{
		motor[leftMotor] = FORWARD_SPEED*LEFT_WHEEL_MOTOR_CORRECTION;		// drive fast straight forward
		motor[rightMotor] = FORWARD_SPEED;

		// if the robot hits a wall while driving,
		if(SensorValue(frontLeftLimitSwitch) || SensorValue(frontRightLimitSwitch))
		{
			backUp();						// back it up,
			stopWheels();					// stop,
			return(SCAN_SECONDARY);			// and conduct a refined search to re-orient to beacon
		}
	}
	return SCAN_SECONDARY;		// we're in close range, so conduct a precise scan to re-orient to beacon.
}



/**
*	closeRangeApproach(): 	drive at a slower speed towards the beacon
* 	input: 					none
* 	output: 				once robot is close enough to pick up, go to TARGET_ACQUIRING
*							otherwise go to SCAN_SECONDARY
*/
State closeRangeApproach()
{
	// drive towards beacon until we're at pick-up distance or lose IR focus
	while((medianFilter() > POINT_BLANK) && (SensorValue(IRsensor) > ambientIR + PRECISE_IR_TOLERANCE))
	{
		motor[leftMotor] = SLOW_SPEED*LEFT_WHEEL_MOTOR_CORRECTION;		// drive slowly straight forward
		motor[rightMotor] = SLOW_SPEED;

		// if the robot hits a wall while driving,
		if(SensorValue(frontLeftLimitSwitch) || SensorValue(frontRightLimitSwitch))
		{
			backUp();						// back it up,
			stopWheels();					// stop,
			return(SCAN_SECONDARY);			// and conduct a refined search to re-orient to beacon
		}
	}
	return TARGET_ACQUIRING;	// we're at pick-up range, so go to target acquisition state
}



/**
*		acquireTarget():	pick-up / load robot with target.
* 		input: 				none
* 		output:				after picking up target, go to DRIVE_TO_WALL
*/
State acquireTarget()
{
	stopWheels();					// must be stationary to pick up

	motor[armMotor] = -20;			// lower swing arm until it bottoms out on chassis
	wait1Msec(1500);
	motor[armMotor] = 0;

	motor[pincerMotor] = -10;		// close pincer,
	wait1Msec(1000);

	motor[pincerMotor] = -30;		// tight squeeze,
	wait1Msec(500);

	motor[pincerMotor] = -10;		// maintain grip.
	wait1Msec(200);

	motor[armMotor] = 30;			// raise arm
	wait1Msec(900);

	motor[armMotor] = 10;			// maintain raised arm (sometimes it fails with weight of target)

	return DRIVE_TO_WALL;			// find a disposal site
}



/**
*		findAWall():		drive up to an arena wall, head on
* 		input: 				none
* 		output:				go to TARGET_DISPOSING
*
*/
State findAWall()
{
	backUp();
	turnAround();

	// until we're directly in front of a wall
	while(medianFilter() > POINT_BLANK)
	{
		motor[leftMotor] = FORWARD_SPEED*LEFT_WHEEL_MOTOR_CORRECTION;		// drive straight forward
		motor[rightMotor] = FORWARD_SPEED;

		// if the robot is crooked to the wall and scrapes left front corner first,
		if(SensorValue(frontLeftLimitSwitch))
		{
			motor[leftMotor] = -(REVERSE_SPEED*LEFT_WHEEL_MOTOR_CORRECTION);	// back it up slightly,
			motor[rightMotor] = -(REVERSE_SPEED);
			wait1Msec(400);

			// until we're square to the wall,
			while(medianFilter() > POINT_BLANK)
			{
				motor[leftMotor] = -(SLOW_SPEED*LEFT_WHEEL_MOTOR_CORRECTION);			// turn slightly left (zero radius),
				motor[rightMotor] = SLOW_SPEED;
			}
			break;	// robot is now square to wall.
		}

		if(SensorValue(frontRightLimitSwitch))	// if the robot is crooked to the wall and scrapes right front corner first,
		{
			motor[leftMotor] = -(REVERSE_SPEED*LEFT_WHEEL_MOTOR_CORRECTION);		// back it up slightly,
			motor[rightMotor] = -(REVERSE_SPEED);
			wait1Msec(400);

			// until we're square to the wall,
			while(medianFilter() > POINT_BLANK)
			{
				motor[leftMotor] = (SLOW_SPEED*LEFT_WHEEL_MOTOR_CORRECTION);			// turn slightly right (zero turn radius)
				motor[rightMotor] = -SLOW_SPEED;
			}
			break;	// robot is now square to wall
		}
	}

	stopWheels();
	return TARGET_DISPOSING;	// robot now faces the wall at point blank, go to target disposal state.
}



/**
*	disposeOfTarget():		release target from pincer
* 	input: 					none
* 	output: 				go to SIGNAL_COMPLETION
*/
State disposeOfTarget()
{
	motor[armMotor] = -10;			//lower arm a bit
	wait1Msec(800);

	motor[pincerMotor] = 20;		//eject target
	wait1Msec(1200);

	motor[pincerMotor] = motor[armMotor] = 0; // turn off arm and pincer motors

	return SIGNAL_COMPLETION;
}



/**
*	taskComplete():		task is finished, so celebrate an appropriate number of times
* 	input: 				none
* 	output: 			return to STANDBY
*/
State taskComplete()
{
	stopWheels();		// Robot stops,

	backUp();			// backs up, begins celebrating.

	for(int i = 0; i < NUMBER_OF_CELEBRATIONS; i++)
	{
		motor[armMotor] = 30;		// Wave arm up,
		wait1Msec(2000);

		motor[armMotor] = -30;	// then down,
		wait1Msec(1000);

		turnAround();			// and turn 90 degrees.
	}

	return(STANDBY);		// return to standby, prepare for next task
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++//
//+++++++++++++++++++++++++++ MAIN ++++++++++++++++++++++++++++//


task main()
{
	State machineState = STANDBY;  //Robot initially in standby mode, awaiting instruction

	while(true)
	{
		// all switch statements are self explanatory, i.e. when state is STANDBY, function is "standingBy"
		switch(machineState)
		{
		case(STANDBY):
			machineState = standingBy();	// polling for button push to initiate program
			break;
		case(SCAN_PRIMARY):
			machineState = primaryScan();	// looking for beacon from afar
			break;
		case(SCAN_SECONDARY):
			machineState = secondaryScan();	// looking for beacon from closer range
			break;
		case(DRIVE_PATROL):
			machineState = onPatrol();		// couldn't find beacon, drive into open space and scan again
			break;
		case(DRIVE_TO_BEACON_FAST):
			machineState = longRangeApproach();	// found beacon, drive toward it quickly
			break;
		case(DRIVE_TO_BEACON_SLOW):
			machineState = closeRangeApproach();	// in close range of beacon, drive toward it slowly
			break;
		case(TARGET_ACQUIRING):
			machineState = acquireTarget();		// pick up target
			break;
		case(DRIVE_TO_WALL):
			machineState = findAWall();		// turn 90 degrees from beacon and drive to a wall
			break;
		case(TARGET_DISPOSING):
			machineState = disposeOfTarget();	// drop target beyond wall
			break;
		case(SIGNAL_COMPLETION):
			machineState = taskComplete();		// indicate task completion by waving swingarm and turning in place
			break;
		default:
		}// end switch block
	}
}// end main
